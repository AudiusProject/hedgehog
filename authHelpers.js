/**
 * WARNING!
 * This file should NOT be modified unless you know what you're doing.
 * All public functions are exposed via hedgehog.js 
 */

const bip39 = require('bip39')
const hdkey = require('ethereumjs-wallet/hdkey')
const randomBytes = require('randombytes')
const CryptoJS = require('crypto-js')
const PBKDF2 = require('crypto-js/pbkdf2')
const Cipher = require('browserify-cipher/browser')
const BufferSafe = require('safe-buffer').Buffer
const Utils = require('./utils')
const authWorker = require('./authWorker.js')

const mode = 'aes-256-cbc'

class AuthHelpers {
  /**
   * Given an entropy string and a HD wallet path, return the wallet address
   * @param {String} entropy Hex string generated by generateMnemonicAndEntropy()
   *                         Looks like `47b0e5e107cccc3297d88647c6e84a9f`
   * @param {String} path Path for hierarchical deterministic wallet
   *                      Looks like `m/44'/60'/0'/0/0`
   * @returns {Object} ethereumjs-wallet wallet object
   */
  static generateWalletFromEntropy (entropy, path) {
    const seed = bip39.mnemonicToSeed(bip39.entropyToMnemonic(entropy))

    // generate HD wallet, not necessary for authentication
    const hdwallet = hdkey.fromMasterSeed(seed)

    // wallet is an ethereumjs-wallet object
    const wallet = hdwallet.derivePath(path).getWallet()

    return wallet
  }

  /**
   * Creates a random mnemonic and creates an entropy string from the mnemonic
   * @returns {Object} `{mnemonic: '...mnemonic string...', entropy: '47b0e5e107cccc3297d88647c6e84a9f'}`
   */
  static generateMnemonicAndEntropy () {
    const mnemonic = bip39.generateMnemonic()

    // this is what we encrypt as private key
    const entropy = bip39.mnemonicToEntropy(mnemonic)

    return { mnemonic: mnemonic, entropy: entropy }
  }

  /**
   * Generate a 16 byte initialization vector and returns it as both a hex string and a buffer
   * @returns {Object} {ivHex: 'ee25d51a4ea4f9db693b9d5dd9459267',
   *                    ivBuffer: Uint8Array(16)[238, 37, 213, 26, 78, 164....]'}
   */
  static createIV () {
    const iv = randomBytes(16)
    const ivHex = iv.toString('hex')

    return { ivHex: ivHex, ivBuffer: iv }
  }

  /**
   * Given a user password and initialization vector, generate a private key
   * @param {String} password String from the user of the password attempt
   * @param {String} ivHex hex string iv value
   * @returns {Object} {keyHex: 'dc4b64f2b3adcc062fad2a051ee5d6ac821d8a7f973954b5be476776f41678f2',
   *                    keyBuffer: Uint8Array(32)[220, 75, 100, 242, 179...]}
   */
  static async createKey (password, ivHex) {
    // if this is browser side, use a web worker to create the key
    // otherwise doing it normally servier side
    if (typeof window !== 'undefined' && window && window.Worker) {
      const worker = new Utils.WebWorker(authWorker.toString())
      worker.postMessage(JSON.stringify({ password, ivHex }))

      return new Promise((resolve, reject) => {
        worker.onmessage = event => {
          resolve(event.data)
        }
      })
    } else {
      const cryptoIV = CryptoJS.enc.Utf8.parse(ivHex) // cryptoJS expects the iv to be in this special format
      const key = PBKDF2(password, cryptoIV, { keySize: 8, iterations: 50000, hasher: CryptoJS.algo.SHA512 })

      // This is the private key
      const keyHex = key.toString(CryptoJS.enc.Hex)
      let keyBuffer = Utils.bufferFromHexString(keyHex)

      return { keyHex: keyHex, keyBuffer: keyBuffer }
    }
  }

  /**
   * Given a iv buffer and key buffer, generate a ciphertext
   * @param {String} entropy Hex string of entropy
   * @param {Buffer} ivBuffer Buffer version of iv
   * @param {Buffer} keyBuffer Buffer version of key
   * @returns {Object} {cipherText: Uint8Array(32)[153, 131, 88, 14, 222, 184...],
   *                    cipherTextHex: '9983580edeb8fc990178fd4b8233c84a9b224952d067a77b23395729d497d820'}
   */
  static encrypt (entropy, ivBuffer, keyBuffer) {
    let encryptFn = Cipher.createCipheriv(mode, keyBuffer, ivBuffer)
    const entropyBuffer = Utils.createEncryptBuffer(entropy)
    let cipherText = BufferSafe.concat([encryptFn.update(entropyBuffer), encryptFn.final()])
    let cipherTextHex = cipherText.toString('hex')

    return { cipherText: cipherText, cipherTextHex: cipherTextHex }
  }

  /**
   * Given an iv buffer, key buffer and ciphertext, decrypt the plaintext value of the entropy
   * @param {Buffer} ivBuffer Buffer version of iv
   * @param {Buffer} keyBuffer Buffer version of key
   * @param {String} cipherTextHex Hex string of the ciphertext
   * @returns {String} Hex string of the entropy. If everything is correct, this should be the same
   *                   as the input entropy, allowing us to check that the generated wallet address
   *                   is the same as the current wallet address for the user
   */
  static decrypt (ivBuffer, keyBuffer, cipherTextHex) {
    let decryptFn = Cipher.createDecipheriv(mode, keyBuffer, ivBuffer)
    let cipherText = BufferSafe.from(Utils.bufferFromHexString(cipherTextHex))
    let decryptedEntorpyBuffer = BufferSafe.concat([decryptFn.update(cipherText), decryptFn.final()])
    let decryptedEntropy = Utils.verifyDecryptString(decryptedEntorpyBuffer)
    return decryptedEntropy
  }
}

module.exports = AuthHelpers