/**
 * WARNING!
 * This file should NOT be modified unless you know what you're doing.
 * All public functions are exposed via hedgehog.js and walletManager.js
 */

import bip39 from "bip39";
import { hdkey } from "ethereumjs-wallet";
import randomBytes from "randombytes";
import crypto from "crypto";
import Cipher from "browserify-cipher/browser";
import { Buffer as BufferSafe } from "safe-buffer";
import { WebWorker, bufferFromHexString } from "./utils";

const mode = "aes-256-cbc";
const encryptPrefixStr = "hedgehog-entropy:::";

type Key = { keyHex: string; keyBuffer: Uint8Array };

export class Authentication {
  /**
   * Given an entropy string and a HD wallet path, return the wallet address
   * @param entropy Hex string generated by generateMnemonicAndEntropy()
   *                         Looks like `47b0e5e107cccc3297d88647c6e84a9f`
   * @param path Path for hierarchical deterministic wallet
   *                      Looks like `m/44'/60'/0'/0/0`
   * @returns ethereumjs-wallet wallet object
   */
  static async generateWalletFromEntropy(entropy: string, path: string) {
    const seed = await bip39.mnemonicToSeed(bip39.entropyToMnemonic(entropy));

    // generate HD wallet, not necessary for authentication
    const hdwallet = hdkey.fromMasterSeed(seed);

    // wallet is an ethereumjs-wallet object
    const wallet = hdwallet.derivePath(path).getWallet();

    return wallet;
  }

  /**
   * Creates a random mnemonic and creates an entropy string from the mnemonic
   * @returns `{mnemonic: '...mnemonic string...', entropy: '47b0e5e107cccc3297d88647c6e84a9f'}`
   */
  static generateMnemonicAndEntropy() {
    const mnemonic = bip39.generateMnemonic();

    // this is what we encrypt as private key
    const entropy = bip39.mnemonicToEntropy(mnemonic);

    return { mnemonic: mnemonic, entropy: entropy };
  }

  /**
   * Generate a 16 byte initialization vector and returns it as both a hex string and a buffer
   */
  static createIV() {
    const ivBuffer = randomBytes(16);
    const ivHex = ivBuffer.toString("hex");

    return { ivHex, ivBuffer };
  }

  /**
   * Given a user encryptStr and initialization vector, generate a private key
   * @param encryptStr String to encrypt (can be user password or some kind of lookup key)
   * @param ivHex hex string iv value
   */
  static async createKey(encryptStr: string, ivHex: string) {
    return new Promise<Key>((resolve, reject) => {
      // if this is browser side, use a web worker to create the key
      // otherwise do it server side with node's crypto module
      if (typeof window !== "undefined" && window && window.Worker) {
        const worker = WebWorker(require("./authWorker.js").toString());
        worker.postMessage(JSON.stringify({ encryptStr, ivHex }));

        worker.onmessage = (event) => {
          resolve(event.data);
        };
      } else {
        const N = 32768;
        const r = 8;
        const p = 1;
        const dkLen = 32;
        const encryptStrBuffer = Buffer.from(encryptStr);
        const ivBuffer = Buffer.from(ivHex);
        // https://github.com/nodejs/node/issues/21524#issuecomment-400012811
        const maxmem = 128 * p * r + 128 * (2 + N) * r;

        crypto.scrypt(
          encryptStrBuffer,
          ivBuffer,
          dkLen,
          { N, r, p, maxmem },
          (err, derivedKey) => {
            if (err) {
              reject(err);
            } else {
              const keyHex = derivedKey.toString("hex");

              // This is the private key
              let keyBuffer = bufferFromHexString(keyHex);

              resolve({ keyHex, keyBuffer });
            }
          }
        );
      }
    });
  }

  /**
   * Given a iv buffer and key buffer, generate a ciphertext
   * @param entropy Hex string of entropy
   * @param ivBuffer Buffer version of iv
   * @param keyBuffer Buffer version of key
   */
  static encrypt(entropy: string, ivBuffer: Buffer, keyBuffer: Uint8Array) {
    let encryptFn = Cipher.createCipheriv(mode, keyBuffer, ivBuffer);
    const entropyBuffer = createEncryptBuffer(entropy);
    let cipherText = BufferSafe.concat([
      encryptFn.update(entropyBuffer),
      encryptFn.final(),
    ]);
    let cipherTextHex = cipherText.toString("hex");

    return { cipherText: cipherText, cipherTextHex: cipherTextHex };
  }

  /**
   * Given an iv buffer, key buffer and ciphertext, decrypt the plaintext value of the entropy
   * @param ivBuffer Buffer version of iv
   * @param keyBuffer Buffer version of key
   * @param cipherTextHex Hex string of the ciphertext
   * @returns Hex string of the entropy. If everything is correct, this should be the same
   *                   as the input entropy, allowing us to check that the generated wallet address
   *                   is the same as the current wallet address for the user
   */
  static decrypt(
    ivBuffer: Uint8Array,
    keyBuffer: Uint8Array,
    cipherTextHex: string
  ) {
    const decryptFn = Cipher.createDecipheriv(mode, keyBuffer, ivBuffer);
    const cipherText = BufferSafe.from(bufferFromHexString(cipherTextHex));
    const decryptedEntropyBuffer = BufferSafe.concat([
      decryptFn.update(cipherText),
      decryptFn.final(),
    ]);
    const decryptedEntropy = verifyDecryptString(decryptedEntropyBuffer);
    return decryptedEntropy;
  }
}

/**
 * This prepends the encryptPrefixStr to the entropy, converts it to a buffer and returns the buffer
 * @param entropy hex string of entropy
 * @returns buffer ready to encrypt via encryptFn
 */
function createEncryptBuffer(entropy: string) {
  let buff = BufferSafe.from(encryptPrefixStr + entropy, "utf8");
  return buff;
}

/**
 * This converts the buffer returned by the `decrypt` function to string, checks that the
 * integrity of the string to check if the encryptPrefixStr exists so we know that the same encrypted value has
 * been decrypted, parses the entropy and returns
 * @param decryptedEntropyBuffer value returned by decryptFn decryption
 * @returns entropy hex string
 */
function verifyDecryptString(decryptedEntropyBuffer: BufferSafe) {
  let decryptedEntrophy = decryptedEntropyBuffer.toString("utf8");

  if (decryptedEntrophy && decryptedEntrophy.indexOf(encryptPrefixStr) === 0) {
    return decryptedEntrophy.split(encryptPrefixStr)[1] as string;
  } else throw new Error("Could not verify integrity of decrypted string");
}
