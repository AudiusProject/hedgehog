/**
 * WARNING!
 * This file should NOT be modified unless you know what you're doing.
 * All public functions are exposed via hedgehog.js and walletManager.js
 */

const bip39 = require('bip39')
const hdkey = require('ethereumjs-wallet/hdkey')
const randomBytes = require('randombytes')
const crypto = require('crypto')
const Cipher = require('browserify-cipher/browser')
const BufferSafe = require('safe-buffer').Buffer
const Utils = require('./utils')
const authWorker = require('./authWorker.js')

const mode = 'aes-256-cbc'
const encryptPrefixStr = 'hedgehog-entropy:::'

class Authentication {
  /**
   * Given an entropy string and a HD wallet path, return the wallet address
   * @param {String} entropy Hex string generated by generateMnemonicAndEntropy()
   *                         Looks like `47b0e5e107cccc3297d88647c6e84a9f`
   * @param {String} path Path for hierarchical deterministic wallet
   *                      Looks like `m/44'/60'/0'/0/0`
   * @returns {Object} ethereumjs-wallet wallet object
   */
  static generateWalletFromEntropy (entropy, path) {
    const seed = bip39.mnemonicToSeed(bip39.entropyToMnemonic(entropy))

    // generate HD wallet, not necessary for authentication
    const hdwallet = hdkey.fromMasterSeed(seed)

    // wallet is an ethereumjs-wallet object
    const wallet = hdwallet.derivePath(path).getWallet()

    return wallet
  }

  /**
   * Creates a random mnemonic and creates an entropy string from the mnemonic
   * @returns {Object} `{mnemonic: '...mnemonic string...', entropy: '47b0e5e107cccc3297d88647c6e84a9f'}`
   */
  static generateMnemonicAndEntropy () {
    const mnemonic = bip39.generateMnemonic()

    // this is what we encrypt as private key
    const entropy = bip39.mnemonicToEntropy(mnemonic)

    return { mnemonic: mnemonic, entropy: entropy }
  }

  /**
   * Generate a 16 byte initialization vector and returns it as both a hex string and a buffer
   * @returns {Object} {ivHex: 'ee25d51a4ea4f9db693b9d5dd9459267',
   *                    ivBuffer: Uint8Array(16)[238, 37, 213, 26, 78, 164....]'}
   */
  static createIV () {
    const iv = randomBytes(16)
    const ivHex = iv.toString('hex')

    return { ivHex: ivHex, ivBuffer: iv }
  }

  /**
   * Given a user password and initialization vector, generate a private key
   * @param {String} password String from the user of the password attempt
   * @param {String} ivHex hex string iv value
   * @returns {Object} {keyHex: 'dc4b64f2b3adcc062fad2a051ee5d6ac821d8a7f973954b5be476776f41678f2',
   *                    keyBuffer: Uint8Array(32)[220, 75, 100, 242, 179...]}
   */
  static async createKey (password, ivHex) {
    return new Promise((resolve, reject) => {
      // if this is browser side, use a web worker to create the key
      // otherwise do it server side with node's crypto module
      if (typeof window !== 'undefined' && window && window.Worker) {
        const worker = Utils.WebWorker(authWorker.toString())
        worker.postMessage(JSON.stringify({ password, ivHex }))

        worker.onmessage = event => {
          resolve(event.data)
        }
      } else {
        const N = 32768
        const r = 8
        const p = 1
        const dkLen = 32
        const passwordBuffer = Buffer.from(password)
        const ivBuffer = Buffer.from(ivHex)
        // https://github.com/nodejs/node/issues/21524#issuecomment-400012811
        const maxmem = 128 * p * r + 128 * (2 + N) * r

        crypto.scrypt(passwordBuffer, ivBuffer, dkLen, { N, r, p, maxmem }, (err, derivedKey) => {
          if (err) {
            reject(err)
          } else {
            const keyHex = derivedKey.toString('hex')

            // This is the private key
            let keyBuffer = Utils.bufferFromHexString(keyHex)

            resolve({ keyHex: keyHex, keyBuffer: keyBuffer })
          }
        })
      }
    })
  }

  /**
   * Given a iv buffer and key buffer, generate a ciphertext
   * @param {String} entropy Hex string of entropy
   * @param {Buffer} ivBuffer Buffer version of iv
   * @param {Buffer} keyBuffer Buffer version of key
   * @returns {Object} {cipherText: Uint8Array(32)[153, 131, 88, 14, 222, 184...],
   *                    cipherTextHex: '9983580edeb8fc990178fd4b8233c84a9b224952d067a77b23395729d497d820'}
   */
  static encrypt (entropy, ivBuffer, keyBuffer) {
    let encryptFn = Cipher.createCipheriv(mode, keyBuffer, ivBuffer)
    const entropyBuffer = createEncryptBuffer(entropy)
    let cipherText = BufferSafe.concat([encryptFn.update(entropyBuffer), encryptFn.final()])
    let cipherTextHex = cipherText.toString('hex')

    return { cipherText: cipherText, cipherTextHex: cipherTextHex }
  }

  /**
   * Given an iv buffer, key buffer and ciphertext, decrypt the plaintext value of the entropy
   * @param {Buffer} ivBuffer Buffer version of iv
   * @param {Buffer} keyBuffer Buffer version of key
   * @param {String} cipherTextHex Hex string of the ciphertext
   * @returns {String} Hex string of the entropy. If everything is correct, this should be the same
   *                   as the input entropy, allowing us to check that the generated wallet address
   *                   is the same as the current wallet address for the user
   */
  static decrypt (ivBuffer, keyBuffer, cipherTextHex) {
    let decryptFn = Cipher.createDecipheriv(mode, keyBuffer, ivBuffer)
    let cipherText = BufferSafe.from(Utils.bufferFromHexString(cipherTextHex))
    let decryptedEntropyBuffer = BufferSafe.concat([decryptFn.update(cipherText), decryptFn.final()])
    let decryptedEntropy = verifyDecryptString(decryptedEntropyBuffer)
    return decryptedEntropy
  }
}

/**
   * This prepends the encryptPrefixStr to the entropy, converts it to a buffer and returns the buffer
   * @param {String} entropy hex string of entropy
   * @returns {Buffer} buffer ready to encrypt via encryptFn
   */
function createEncryptBuffer (entropy) {
  let buff = BufferSafe.from(encryptPrefixStr + entropy, 'utf8')
  return buff
}

/**
   * This converts the buffer returned by the `decrypt` function to string, checks that the
   * integrity of the string to check if the encryptPrefixStr exists so we know that the same encrypted value has
   * been decrypted, parses the entropy and returns
   * @param {Buffer} decryptedEntropyBuffer value returned by decryptFn decryption
   * @returns {String} entropy hex string
   */
function verifyDecryptString (decryptedEntropyBuffer) {
  let decryptedEntrophy = decryptedEntropyBuffer.toString('utf8')

  if (decryptedEntrophy && decryptedEntrophy.indexOf(encryptPrefixStr) === 0) {
    return decryptedEntrophy.split(encryptPrefixStr)[1]
  } else throw new Error('Could not verify integrity of decrypted string')
}

module.exports = Authentication
